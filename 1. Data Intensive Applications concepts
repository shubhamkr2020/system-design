Concepts from the book Data Intensive applications: https://drive.google.com/file/d/130K3odqXWmp4hYn1ykT-b8dLYuVpJ_n3/view?usp=drive_link

Chapter 1: Reliability, Scalability, Maintainability

1. What is Reliability, Scalability, Maintainability



Chapter 2: Database models and query language

1. when to use relational vs non relational model:
    a. document model is flexible and close to the data structures used in the applications.
    b. relational model helps in join or if there are many/one to many/one relationships.
2. 



Chapter 3: Storage and Retrieval

1. Analytical and Transactional Databases
2. 


Chapter 4: Encoding and Evolution

1. Encoding and why is it needed.
  a .Since in-memory data strucutres are optimised for access in the applications mostly using pointers of the address spaces,
  They cannot be used to transfer the data over network. So we need encoding or serialisation to transfer the data using byte sequences.
2. protocoll buffers and thrift encoding
3. data flow between processes:
  a. via databases - update the database using encoding and then fetch from the other process by decoding it.
  b. via service calls - direct RPCs to a process of a service, encode/decode the requests and responses before sending.
  c. via asynchronous message passing - kafka queue as a middle ware. encoded by the senders and decoded by the receivers over a topic (multiple senders and recievers).
4. 


Chapter 5: Replication

1. Single Leader -
  a. all writes to single node and reads from multiple nodes synced to the leader.
  b. synchronous and asynchronous followers, usually single sync and rest async
  c. async followers are eventually consistent
  d. failover - when leader is down, make a follower the leader and proceed forward, mostly done manually due to many issues.

2. Multi Leader - 
  a. writes to multiple leaders and sync to others and read from anyone.
  b. mostly not used, very complex and not that benfecial.
  c. topologies of the multi leader replications

3. Leaderless - 
  a. widely used these days, dynamo stlye (amazon internal db) but not dynamo db (it is single leader)
  b. multiple node writes and multiple node reads.
  c. directly update to multiple replicas or keep a cordinator (not leader) to do the updates on multiple replicas.
  d. no failovers in leaderless since there is no leader.
  e. Quorums for read and write - usually configurable n, w, r values in the leaderless DBs.



Chapter 6: Partition

1. partition using hash of keys
  loose the key range query efficiency since it will now be sent many nodes instead of one but the load at one is decreased in general.
2. consistent hashing - evenly distribute the load
  a. 



